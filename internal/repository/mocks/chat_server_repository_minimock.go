// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/markgenuine/chat-server/internal/repository.ChatServerRepository -o chat_server_repository_minimock.go -n ChatServerRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/markgenuine/chat-server/internal/model"
)

// ChatServerRepositoryMock implements repository.ChatServerRepository
type ChatServerRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, chat *model.Chat) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, chat *model.Chat)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mChatServerRepositoryMockCreate

	funcDeleteChatMessages          func(ctx context.Context, id int64) (err error)
	inspectFuncDeleteChatMessages   func(ctx context.Context, id int64)
	afterDeleteChatMessagesCounter  uint64
	beforeDeleteChatMessagesCounter uint64
	DeleteChatMessagesMock          mChatServerRepositoryMockDeleteChatMessages

	funcDeleteChatUsers          func(ctx context.Context, id int64) (err error)
	inspectFuncDeleteChatUsers   func(ctx context.Context, id int64)
	afterDeleteChatUsersCounter  uint64
	beforeDeleteChatUsersCounter uint64
	DeleteChatUsersMock          mChatServerRepositoryMockDeleteChatUsers

	funcDeleteChatsUsers          func(ctx context.Context, id int64) (err error)
	inspectFuncDeleteChatsUsers   func(ctx context.Context, id int64)
	afterDeleteChatsUsersCounter  uint64
	beforeDeleteChatsUsersCounter uint64
	DeleteChatsUsersMock          mChatServerRepositoryMockDeleteChatsUsers

	funcSendMessage          func(ctx context.Context, message *model.Message) (err error)
	inspectFuncSendMessage   func(ctx context.Context, message *model.Message)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServerRepositoryMockSendMessage
}

// NewChatServerRepositoryMock returns a mock for repository.ChatServerRepository
func NewChatServerRepositoryMock(t minimock.Tester) *ChatServerRepositoryMock {
	m := &ChatServerRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mChatServerRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*ChatServerRepositoryMockCreateParams{}

	m.DeleteChatMessagesMock = mChatServerRepositoryMockDeleteChatMessages{mock: m}
	m.DeleteChatMessagesMock.callArgs = []*ChatServerRepositoryMockDeleteChatMessagesParams{}

	m.DeleteChatUsersMock = mChatServerRepositoryMockDeleteChatUsers{mock: m}
	m.DeleteChatUsersMock.callArgs = []*ChatServerRepositoryMockDeleteChatUsersParams{}

	m.DeleteChatsUsersMock = mChatServerRepositoryMockDeleteChatsUsers{mock: m}
	m.DeleteChatsUsersMock.callArgs = []*ChatServerRepositoryMockDeleteChatsUsersParams{}

	m.SendMessageMock = mChatServerRepositoryMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServerRepositoryMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServerRepositoryMockCreate struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockCreateExpectation
	expectations       []*ChatServerRepositoryMockCreateExpectation

	callArgs []*ChatServerRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockCreateExpectation specifies expectation struct of the ChatServerRepository.Create
type ChatServerRepositoryMockCreateExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockCreateParams
	results *ChatServerRepositoryMockCreateResults
	Counter uint64
}

// ChatServerRepositoryMockCreateParams contains parameters of the ChatServerRepository.Create
type ChatServerRepositoryMockCreateParams struct {
	ctx  context.Context
	chat *model.Chat
}

// ChatServerRepositoryMockCreateResults contains results of the ChatServerRepository.Create
type ChatServerRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for ChatServerRepository.Create
func (mmCreate *mChatServerRepositoryMockCreate) Expect(ctx context.Context, chat *model.Chat) *mChatServerRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServerRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServerRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &ChatServerRepositoryMockCreateParams{ctx, chat}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.Create
func (mmCreate *mChatServerRepositoryMockCreate) Inspect(f func(ctx context.Context, chat *model.Chat)) *mChatServerRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ChatServerRepository.Create
func (mmCreate *mChatServerRepositoryMockCreate) Return(i1 int64, err error) *ChatServerRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServerRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServerRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ChatServerRepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the ChatServerRepository.Create method
func (mmCreate *mChatServerRepositoryMockCreate) Set(f func(ctx context.Context, chat *model.Chat) (i1 int64, err error)) *ChatServerRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the ChatServerRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mChatServerRepositoryMockCreate) When(ctx context.Context, chat *model.Chat) *ChatServerRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServerRepositoryMock.Create mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ChatServerRepositoryMockCreateParams{ctx, chat},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.Create return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockCreateExpectation) Then(i1 int64, err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Create implements repository.ChatServerRepository
func (mmCreate *ChatServerRepositoryMock) Create(ctx context.Context, chat *model.Chat) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, chat)
	}

	mm_params := ChatServerRepositoryMockCreateParams{ctx, chat}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockCreateParams{ctx, chat}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ChatServerRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ChatServerRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, chat)
	}
	mmCreate.t.Fatalf("Unexpected call to ChatServerRepositoryMock.Create. %v %v", ctx, chat)
	return
}

// CreateAfterCounter returns a count of finished ChatServerRepositoryMock.Create invocations
func (mmCreate *ChatServerRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ChatServerRepositoryMock.Create invocations
func (mmCreate *ChatServerRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mChatServerRepositoryMockCreate) Calls() []*ChatServerRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.Create")
	}
}

type mChatServerRepositoryMockDeleteChatMessages struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockDeleteChatMessagesExpectation
	expectations       []*ChatServerRepositoryMockDeleteChatMessagesExpectation

	callArgs []*ChatServerRepositoryMockDeleteChatMessagesParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockDeleteChatMessagesExpectation specifies expectation struct of the ChatServerRepository.DeleteChatMessages
type ChatServerRepositoryMockDeleteChatMessagesExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockDeleteChatMessagesParams
	results *ChatServerRepositoryMockDeleteChatMessagesResults
	Counter uint64
}

// ChatServerRepositoryMockDeleteChatMessagesParams contains parameters of the ChatServerRepository.DeleteChatMessages
type ChatServerRepositoryMockDeleteChatMessagesParams struct {
	ctx context.Context
	id  int64
}

// ChatServerRepositoryMockDeleteChatMessagesResults contains results of the ChatServerRepository.DeleteChatMessages
type ChatServerRepositoryMockDeleteChatMessagesResults struct {
	err error
}

// Expect sets up expected params for ChatServerRepository.DeleteChatMessages
func (mmDeleteChatMessages *mChatServerRepositoryMockDeleteChatMessages) Expect(ctx context.Context, id int64) *mChatServerRepositoryMockDeleteChatMessages {
	if mmDeleteChatMessages.mock.funcDeleteChatMessages != nil {
		mmDeleteChatMessages.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMessages mock is already set by Set")
	}

	if mmDeleteChatMessages.defaultExpectation == nil {
		mmDeleteChatMessages.defaultExpectation = &ChatServerRepositoryMockDeleteChatMessagesExpectation{}
	}

	mmDeleteChatMessages.defaultExpectation.params = &ChatServerRepositoryMockDeleteChatMessagesParams{ctx, id}
	for _, e := range mmDeleteChatMessages.expectations {
		if minimock.Equal(e.params, mmDeleteChatMessages.defaultExpectation.params) {
			mmDeleteChatMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChatMessages.defaultExpectation.params)
		}
	}

	return mmDeleteChatMessages
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.DeleteChatMessages
func (mmDeleteChatMessages *mChatServerRepositoryMockDeleteChatMessages) Inspect(f func(ctx context.Context, id int64)) *mChatServerRepositoryMockDeleteChatMessages {
	if mmDeleteChatMessages.mock.inspectFuncDeleteChatMessages != nil {
		mmDeleteChatMessages.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.DeleteChatMessages")
	}

	mmDeleteChatMessages.mock.inspectFuncDeleteChatMessages = f

	return mmDeleteChatMessages
}

// Return sets up results that will be returned by ChatServerRepository.DeleteChatMessages
func (mmDeleteChatMessages *mChatServerRepositoryMockDeleteChatMessages) Return(err error) *ChatServerRepositoryMock {
	if mmDeleteChatMessages.mock.funcDeleteChatMessages != nil {
		mmDeleteChatMessages.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMessages mock is already set by Set")
	}

	if mmDeleteChatMessages.defaultExpectation == nil {
		mmDeleteChatMessages.defaultExpectation = &ChatServerRepositoryMockDeleteChatMessagesExpectation{mock: mmDeleteChatMessages.mock}
	}
	mmDeleteChatMessages.defaultExpectation.results = &ChatServerRepositoryMockDeleteChatMessagesResults{err}
	return mmDeleteChatMessages.mock
}

// Set uses given function f to mock the ChatServerRepository.DeleteChatMessages method
func (mmDeleteChatMessages *mChatServerRepositoryMockDeleteChatMessages) Set(f func(ctx context.Context, id int64) (err error)) *ChatServerRepositoryMock {
	if mmDeleteChatMessages.defaultExpectation != nil {
		mmDeleteChatMessages.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.DeleteChatMessages method")
	}

	if len(mmDeleteChatMessages.expectations) > 0 {
		mmDeleteChatMessages.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.DeleteChatMessages method")
	}

	mmDeleteChatMessages.mock.funcDeleteChatMessages = f
	return mmDeleteChatMessages.mock
}

// When sets expectation for the ChatServerRepository.DeleteChatMessages which will trigger the result defined by the following
// Then helper
func (mmDeleteChatMessages *mChatServerRepositoryMockDeleteChatMessages) When(ctx context.Context, id int64) *ChatServerRepositoryMockDeleteChatMessagesExpectation {
	if mmDeleteChatMessages.mock.funcDeleteChatMessages != nil {
		mmDeleteChatMessages.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatMessages mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockDeleteChatMessagesExpectation{
		mock:   mmDeleteChatMessages.mock,
		params: &ChatServerRepositoryMockDeleteChatMessagesParams{ctx, id},
	}
	mmDeleteChatMessages.expectations = append(mmDeleteChatMessages.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.DeleteChatMessages return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockDeleteChatMessagesExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockDeleteChatMessagesResults{err}
	return e.mock
}

// DeleteChatMessages implements repository.ChatServerRepository
func (mmDeleteChatMessages *ChatServerRepositoryMock) DeleteChatMessages(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChatMessages.beforeDeleteChatMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChatMessages.afterDeleteChatMessagesCounter, 1)

	if mmDeleteChatMessages.inspectFuncDeleteChatMessages != nil {
		mmDeleteChatMessages.inspectFuncDeleteChatMessages(ctx, id)
	}

	mm_params := ChatServerRepositoryMockDeleteChatMessagesParams{ctx, id}

	// Record call args
	mmDeleteChatMessages.DeleteChatMessagesMock.mutex.Lock()
	mmDeleteChatMessages.DeleteChatMessagesMock.callArgs = append(mmDeleteChatMessages.DeleteChatMessagesMock.callArgs, &mm_params)
	mmDeleteChatMessages.DeleteChatMessagesMock.mutex.Unlock()

	for _, e := range mmDeleteChatMessages.DeleteChatMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChatMessages.DeleteChatMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChatMessages.DeleteChatMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChatMessages.DeleteChatMessagesMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockDeleteChatMessagesParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChatMessages.t.Errorf("ChatServerRepositoryMock.DeleteChatMessages got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChatMessages.DeleteChatMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChatMessages.t.Fatal("No results are set for the ChatServerRepositoryMock.DeleteChatMessages")
		}
		return (*mm_results).err
	}
	if mmDeleteChatMessages.funcDeleteChatMessages != nil {
		return mmDeleteChatMessages.funcDeleteChatMessages(ctx, id)
	}
	mmDeleteChatMessages.t.Fatalf("Unexpected call to ChatServerRepositoryMock.DeleteChatMessages. %v %v", ctx, id)
	return
}

// DeleteChatMessagesAfterCounter returns a count of finished ChatServerRepositoryMock.DeleteChatMessages invocations
func (mmDeleteChatMessages *ChatServerRepositoryMock) DeleteChatMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatMessages.afterDeleteChatMessagesCounter)
}

// DeleteChatMessagesBeforeCounter returns a count of ChatServerRepositoryMock.DeleteChatMessages invocations
func (mmDeleteChatMessages *ChatServerRepositoryMock) DeleteChatMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatMessages.beforeDeleteChatMessagesCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.DeleteChatMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChatMessages *mChatServerRepositoryMockDeleteChatMessages) Calls() []*ChatServerRepositoryMockDeleteChatMessagesParams {
	mmDeleteChatMessages.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockDeleteChatMessagesParams, len(mmDeleteChatMessages.callArgs))
	copy(argCopy, mmDeleteChatMessages.callArgs)

	mmDeleteChatMessages.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatMessagesDone returns true if the count of the DeleteChatMessages invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockDeleteChatMessagesDone() bool {
	for _, e := range m.DeleteChatMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatMessagesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChatMessages != nil && mm_atomic.LoadUint64(&m.afterDeleteChatMessagesCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteChatMessagesInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockDeleteChatMessagesInspect() {
	for _, e := range m.DeleteChatMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChatMessages with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMessagesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatMessagesCounter) < 1 {
		if m.DeleteChatMessagesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.DeleteChatMessages")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChatMessages with params: %#v", *m.DeleteChatMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChatMessages != nil && mm_atomic.LoadUint64(&m.afterDeleteChatMessagesCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.DeleteChatMessages")
	}
}

type mChatServerRepositoryMockDeleteChatUsers struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockDeleteChatUsersExpectation
	expectations       []*ChatServerRepositoryMockDeleteChatUsersExpectation

	callArgs []*ChatServerRepositoryMockDeleteChatUsersParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockDeleteChatUsersExpectation specifies expectation struct of the ChatServerRepository.DeleteChatUsers
type ChatServerRepositoryMockDeleteChatUsersExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockDeleteChatUsersParams
	results *ChatServerRepositoryMockDeleteChatUsersResults
	Counter uint64
}

// ChatServerRepositoryMockDeleteChatUsersParams contains parameters of the ChatServerRepository.DeleteChatUsers
type ChatServerRepositoryMockDeleteChatUsersParams struct {
	ctx context.Context
	id  int64
}

// ChatServerRepositoryMockDeleteChatUsersResults contains results of the ChatServerRepository.DeleteChatUsers
type ChatServerRepositoryMockDeleteChatUsersResults struct {
	err error
}

// Expect sets up expected params for ChatServerRepository.DeleteChatUsers
func (mmDeleteChatUsers *mChatServerRepositoryMockDeleteChatUsers) Expect(ctx context.Context, id int64) *mChatServerRepositoryMockDeleteChatUsers {
	if mmDeleteChatUsers.mock.funcDeleteChatUsers != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatUsers mock is already set by Set")
	}

	if mmDeleteChatUsers.defaultExpectation == nil {
		mmDeleteChatUsers.defaultExpectation = &ChatServerRepositoryMockDeleteChatUsersExpectation{}
	}

	mmDeleteChatUsers.defaultExpectation.params = &ChatServerRepositoryMockDeleteChatUsersParams{ctx, id}
	for _, e := range mmDeleteChatUsers.expectations {
		if minimock.Equal(e.params, mmDeleteChatUsers.defaultExpectation.params) {
			mmDeleteChatUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChatUsers.defaultExpectation.params)
		}
	}

	return mmDeleteChatUsers
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.DeleteChatUsers
func (mmDeleteChatUsers *mChatServerRepositoryMockDeleteChatUsers) Inspect(f func(ctx context.Context, id int64)) *mChatServerRepositoryMockDeleteChatUsers {
	if mmDeleteChatUsers.mock.inspectFuncDeleteChatUsers != nil {
		mmDeleteChatUsers.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.DeleteChatUsers")
	}

	mmDeleteChatUsers.mock.inspectFuncDeleteChatUsers = f

	return mmDeleteChatUsers
}

// Return sets up results that will be returned by ChatServerRepository.DeleteChatUsers
func (mmDeleteChatUsers *mChatServerRepositoryMockDeleteChatUsers) Return(err error) *ChatServerRepositoryMock {
	if mmDeleteChatUsers.mock.funcDeleteChatUsers != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatUsers mock is already set by Set")
	}

	if mmDeleteChatUsers.defaultExpectation == nil {
		mmDeleteChatUsers.defaultExpectation = &ChatServerRepositoryMockDeleteChatUsersExpectation{mock: mmDeleteChatUsers.mock}
	}
	mmDeleteChatUsers.defaultExpectation.results = &ChatServerRepositoryMockDeleteChatUsersResults{err}
	return mmDeleteChatUsers.mock
}

// Set uses given function f to mock the ChatServerRepository.DeleteChatUsers method
func (mmDeleteChatUsers *mChatServerRepositoryMockDeleteChatUsers) Set(f func(ctx context.Context, id int64) (err error)) *ChatServerRepositoryMock {
	if mmDeleteChatUsers.defaultExpectation != nil {
		mmDeleteChatUsers.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.DeleteChatUsers method")
	}

	if len(mmDeleteChatUsers.expectations) > 0 {
		mmDeleteChatUsers.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.DeleteChatUsers method")
	}

	mmDeleteChatUsers.mock.funcDeleteChatUsers = f
	return mmDeleteChatUsers.mock
}

// When sets expectation for the ChatServerRepository.DeleteChatUsers which will trigger the result defined by the following
// Then helper
func (mmDeleteChatUsers *mChatServerRepositoryMockDeleteChatUsers) When(ctx context.Context, id int64) *ChatServerRepositoryMockDeleteChatUsersExpectation {
	if mmDeleteChatUsers.mock.funcDeleteChatUsers != nil {
		mmDeleteChatUsers.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatUsers mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockDeleteChatUsersExpectation{
		mock:   mmDeleteChatUsers.mock,
		params: &ChatServerRepositoryMockDeleteChatUsersParams{ctx, id},
	}
	mmDeleteChatUsers.expectations = append(mmDeleteChatUsers.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.DeleteChatUsers return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockDeleteChatUsersExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockDeleteChatUsersResults{err}
	return e.mock
}

// DeleteChatUsers implements repository.ChatServerRepository
func (mmDeleteChatUsers *ChatServerRepositoryMock) DeleteChatUsers(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChatUsers.beforeDeleteChatUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChatUsers.afterDeleteChatUsersCounter, 1)

	if mmDeleteChatUsers.inspectFuncDeleteChatUsers != nil {
		mmDeleteChatUsers.inspectFuncDeleteChatUsers(ctx, id)
	}

	mm_params := ChatServerRepositoryMockDeleteChatUsersParams{ctx, id}

	// Record call args
	mmDeleteChatUsers.DeleteChatUsersMock.mutex.Lock()
	mmDeleteChatUsers.DeleteChatUsersMock.callArgs = append(mmDeleteChatUsers.DeleteChatUsersMock.callArgs, &mm_params)
	mmDeleteChatUsers.DeleteChatUsersMock.mutex.Unlock()

	for _, e := range mmDeleteChatUsers.DeleteChatUsersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChatUsers.DeleteChatUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChatUsers.DeleteChatUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChatUsers.DeleteChatUsersMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockDeleteChatUsersParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChatUsers.t.Errorf("ChatServerRepositoryMock.DeleteChatUsers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChatUsers.DeleteChatUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChatUsers.t.Fatal("No results are set for the ChatServerRepositoryMock.DeleteChatUsers")
		}
		return (*mm_results).err
	}
	if mmDeleteChatUsers.funcDeleteChatUsers != nil {
		return mmDeleteChatUsers.funcDeleteChatUsers(ctx, id)
	}
	mmDeleteChatUsers.t.Fatalf("Unexpected call to ChatServerRepositoryMock.DeleteChatUsers. %v %v", ctx, id)
	return
}

// DeleteChatUsersAfterCounter returns a count of finished ChatServerRepositoryMock.DeleteChatUsers invocations
func (mmDeleteChatUsers *ChatServerRepositoryMock) DeleteChatUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatUsers.afterDeleteChatUsersCounter)
}

// DeleteChatUsersBeforeCounter returns a count of ChatServerRepositoryMock.DeleteChatUsers invocations
func (mmDeleteChatUsers *ChatServerRepositoryMock) DeleteChatUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatUsers.beforeDeleteChatUsersCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.DeleteChatUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChatUsers *mChatServerRepositoryMockDeleteChatUsers) Calls() []*ChatServerRepositoryMockDeleteChatUsersParams {
	mmDeleteChatUsers.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockDeleteChatUsersParams, len(mmDeleteChatUsers.callArgs))
	copy(argCopy, mmDeleteChatUsers.callArgs)

	mmDeleteChatUsers.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatUsersDone returns true if the count of the DeleteChatUsers invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockDeleteChatUsersDone() bool {
	for _, e := range m.DeleteChatUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatUsersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChatUsers != nil && mm_atomic.LoadUint64(&m.afterDeleteChatUsersCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteChatUsersInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockDeleteChatUsersInspect() {
	for _, e := range m.DeleteChatUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChatUsers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatUsersCounter) < 1 {
		if m.DeleteChatUsersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.DeleteChatUsers")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChatUsers with params: %#v", *m.DeleteChatUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChatUsers != nil && mm_atomic.LoadUint64(&m.afterDeleteChatUsersCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.DeleteChatUsers")
	}
}

type mChatServerRepositoryMockDeleteChatsUsers struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockDeleteChatsUsersExpectation
	expectations       []*ChatServerRepositoryMockDeleteChatsUsersExpectation

	callArgs []*ChatServerRepositoryMockDeleteChatsUsersParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockDeleteChatsUsersExpectation specifies expectation struct of the ChatServerRepository.DeleteChatsUsers
type ChatServerRepositoryMockDeleteChatsUsersExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockDeleteChatsUsersParams
	results *ChatServerRepositoryMockDeleteChatsUsersResults
	Counter uint64
}

// ChatServerRepositoryMockDeleteChatsUsersParams contains parameters of the ChatServerRepository.DeleteChatsUsers
type ChatServerRepositoryMockDeleteChatsUsersParams struct {
	ctx context.Context
	id  int64
}

// ChatServerRepositoryMockDeleteChatsUsersResults contains results of the ChatServerRepository.DeleteChatsUsers
type ChatServerRepositoryMockDeleteChatsUsersResults struct {
	err error
}

// Expect sets up expected params for ChatServerRepository.DeleteChatsUsers
func (mmDeleteChatsUsers *mChatServerRepositoryMockDeleteChatsUsers) Expect(ctx context.Context, id int64) *mChatServerRepositoryMockDeleteChatsUsers {
	if mmDeleteChatsUsers.mock.funcDeleteChatsUsers != nil {
		mmDeleteChatsUsers.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatsUsers mock is already set by Set")
	}

	if mmDeleteChatsUsers.defaultExpectation == nil {
		mmDeleteChatsUsers.defaultExpectation = &ChatServerRepositoryMockDeleteChatsUsersExpectation{}
	}

	mmDeleteChatsUsers.defaultExpectation.params = &ChatServerRepositoryMockDeleteChatsUsersParams{ctx, id}
	for _, e := range mmDeleteChatsUsers.expectations {
		if minimock.Equal(e.params, mmDeleteChatsUsers.defaultExpectation.params) {
			mmDeleteChatsUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChatsUsers.defaultExpectation.params)
		}
	}

	return mmDeleteChatsUsers
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.DeleteChatsUsers
func (mmDeleteChatsUsers *mChatServerRepositoryMockDeleteChatsUsers) Inspect(f func(ctx context.Context, id int64)) *mChatServerRepositoryMockDeleteChatsUsers {
	if mmDeleteChatsUsers.mock.inspectFuncDeleteChatsUsers != nil {
		mmDeleteChatsUsers.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.DeleteChatsUsers")
	}

	mmDeleteChatsUsers.mock.inspectFuncDeleteChatsUsers = f

	return mmDeleteChatsUsers
}

// Return sets up results that will be returned by ChatServerRepository.DeleteChatsUsers
func (mmDeleteChatsUsers *mChatServerRepositoryMockDeleteChatsUsers) Return(err error) *ChatServerRepositoryMock {
	if mmDeleteChatsUsers.mock.funcDeleteChatsUsers != nil {
		mmDeleteChatsUsers.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatsUsers mock is already set by Set")
	}

	if mmDeleteChatsUsers.defaultExpectation == nil {
		mmDeleteChatsUsers.defaultExpectation = &ChatServerRepositoryMockDeleteChatsUsersExpectation{mock: mmDeleteChatsUsers.mock}
	}
	mmDeleteChatsUsers.defaultExpectation.results = &ChatServerRepositoryMockDeleteChatsUsersResults{err}
	return mmDeleteChatsUsers.mock
}

// Set uses given function f to mock the ChatServerRepository.DeleteChatsUsers method
func (mmDeleteChatsUsers *mChatServerRepositoryMockDeleteChatsUsers) Set(f func(ctx context.Context, id int64) (err error)) *ChatServerRepositoryMock {
	if mmDeleteChatsUsers.defaultExpectation != nil {
		mmDeleteChatsUsers.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.DeleteChatsUsers method")
	}

	if len(mmDeleteChatsUsers.expectations) > 0 {
		mmDeleteChatsUsers.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.DeleteChatsUsers method")
	}

	mmDeleteChatsUsers.mock.funcDeleteChatsUsers = f
	return mmDeleteChatsUsers.mock
}

// When sets expectation for the ChatServerRepository.DeleteChatsUsers which will trigger the result defined by the following
// Then helper
func (mmDeleteChatsUsers *mChatServerRepositoryMockDeleteChatsUsers) When(ctx context.Context, id int64) *ChatServerRepositoryMockDeleteChatsUsersExpectation {
	if mmDeleteChatsUsers.mock.funcDeleteChatsUsers != nil {
		mmDeleteChatsUsers.mock.t.Fatalf("ChatServerRepositoryMock.DeleteChatsUsers mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockDeleteChatsUsersExpectation{
		mock:   mmDeleteChatsUsers.mock,
		params: &ChatServerRepositoryMockDeleteChatsUsersParams{ctx, id},
	}
	mmDeleteChatsUsers.expectations = append(mmDeleteChatsUsers.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.DeleteChatsUsers return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockDeleteChatsUsersExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockDeleteChatsUsersResults{err}
	return e.mock
}

// DeleteChatsUsers implements repository.ChatServerRepository
func (mmDeleteChatsUsers *ChatServerRepositoryMock) DeleteChatsUsers(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChatsUsers.beforeDeleteChatsUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChatsUsers.afterDeleteChatsUsersCounter, 1)

	if mmDeleteChatsUsers.inspectFuncDeleteChatsUsers != nil {
		mmDeleteChatsUsers.inspectFuncDeleteChatsUsers(ctx, id)
	}

	mm_params := ChatServerRepositoryMockDeleteChatsUsersParams{ctx, id}

	// Record call args
	mmDeleteChatsUsers.DeleteChatsUsersMock.mutex.Lock()
	mmDeleteChatsUsers.DeleteChatsUsersMock.callArgs = append(mmDeleteChatsUsers.DeleteChatsUsersMock.callArgs, &mm_params)
	mmDeleteChatsUsers.DeleteChatsUsersMock.mutex.Unlock()

	for _, e := range mmDeleteChatsUsers.DeleteChatsUsersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChatsUsers.DeleteChatsUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChatsUsers.DeleteChatsUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChatsUsers.DeleteChatsUsersMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockDeleteChatsUsersParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChatsUsers.t.Errorf("ChatServerRepositoryMock.DeleteChatsUsers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChatsUsers.DeleteChatsUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChatsUsers.t.Fatal("No results are set for the ChatServerRepositoryMock.DeleteChatsUsers")
		}
		return (*mm_results).err
	}
	if mmDeleteChatsUsers.funcDeleteChatsUsers != nil {
		return mmDeleteChatsUsers.funcDeleteChatsUsers(ctx, id)
	}
	mmDeleteChatsUsers.t.Fatalf("Unexpected call to ChatServerRepositoryMock.DeleteChatsUsers. %v %v", ctx, id)
	return
}

// DeleteChatsUsersAfterCounter returns a count of finished ChatServerRepositoryMock.DeleteChatsUsers invocations
func (mmDeleteChatsUsers *ChatServerRepositoryMock) DeleteChatsUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatsUsers.afterDeleteChatsUsersCounter)
}

// DeleteChatsUsersBeforeCounter returns a count of ChatServerRepositoryMock.DeleteChatsUsers invocations
func (mmDeleteChatsUsers *ChatServerRepositoryMock) DeleteChatsUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChatsUsers.beforeDeleteChatsUsersCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.DeleteChatsUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChatsUsers *mChatServerRepositoryMockDeleteChatsUsers) Calls() []*ChatServerRepositoryMockDeleteChatsUsersParams {
	mmDeleteChatsUsers.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockDeleteChatsUsersParams, len(mmDeleteChatsUsers.callArgs))
	copy(argCopy, mmDeleteChatsUsers.callArgs)

	mmDeleteChatsUsers.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatsUsersDone returns true if the count of the DeleteChatsUsers invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockDeleteChatsUsersDone() bool {
	for _, e := range m.DeleteChatsUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatsUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatsUsersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChatsUsers != nil && mm_atomic.LoadUint64(&m.afterDeleteChatsUsersCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteChatsUsersInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockDeleteChatsUsersInspect() {
	for _, e := range m.DeleteChatsUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChatsUsers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatsUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteChatsUsersCounter) < 1 {
		if m.DeleteChatsUsersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.DeleteChatsUsers")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.DeleteChatsUsers with params: %#v", *m.DeleteChatsUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChatsUsers != nil && mm_atomic.LoadUint64(&m.afterDeleteChatsUsersCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.DeleteChatsUsers")
	}
}

type mChatServerRepositoryMockSendMessage struct {
	mock               *ChatServerRepositoryMock
	defaultExpectation *ChatServerRepositoryMockSendMessageExpectation
	expectations       []*ChatServerRepositoryMockSendMessageExpectation

	callArgs []*ChatServerRepositoryMockSendMessageParams
	mutex    sync.RWMutex
}

// ChatServerRepositoryMockSendMessageExpectation specifies expectation struct of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageExpectation struct {
	mock    *ChatServerRepositoryMock
	params  *ChatServerRepositoryMockSendMessageParams
	results *ChatServerRepositoryMockSendMessageResults
	Counter uint64
}

// ChatServerRepositoryMockSendMessageParams contains parameters of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageParams struct {
	ctx     context.Context
	message *model.Message
}

// ChatServerRepositoryMockSendMessageResults contains results of the ChatServerRepository.SendMessage
type ChatServerRepositoryMockSendMessageResults struct {
	err error
}

// Expect sets up expected params for ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Expect(ctx context.Context, message *model.Message) *mChatServerRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServerRepositoryMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &ChatServerRepositoryMockSendMessageParams{ctx, message}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Inspect(f func(ctx context.Context, message *model.Message)) *mChatServerRepositoryMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServerRepositoryMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatServerRepository.SendMessage
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Return(err error) *ChatServerRepositoryMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServerRepositoryMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServerRepositoryMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatServerRepository.SendMessage method
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Set(f func(ctx context.Context, message *model.Message) (err error)) *ChatServerRepositoryMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatServerRepository.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatServerRepository.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatServerRepository.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServerRepositoryMockSendMessage) When(ctx context.Context, message *model.Message) *ChatServerRepositoryMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServerRepositoryMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServerRepositoryMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatServerRepositoryMockSendMessageParams{ctx, message},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatServerRepository.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServerRepositoryMockSendMessageExpectation) Then(err error) *ChatServerRepositoryMock {
	e.results = &ChatServerRepositoryMockSendMessageResults{err}
	return e.mock
}

// SendMessage implements repository.ChatServerRepository
func (mmSendMessage *ChatServerRepositoryMock) SendMessage(ctx context.Context, message *model.Message) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, message)
	}

	mm_params := ChatServerRepositoryMockSendMessageParams{ctx, message}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_got := ChatServerRepositoryMockSendMessageParams{ctx, message}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServerRepositoryMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServerRepositoryMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, message)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServerRepositoryMock.SendMessage. %v %v", ctx, message)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServerRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatServerRepositoryMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServerRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatServerRepositoryMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServerRepositoryMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServerRepositoryMockSendMessage) Calls() []*ChatServerRepositoryMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServerRepositoryMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServerRepositoryMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServerRepositoryMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServerRepositoryMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatServerRepositoryMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to ChatServerRepositoryMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServerRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteChatMessagesInspect()

			m.MinimockDeleteChatUsersInspect()

			m.MinimockDeleteChatsUsersInspect()

			m.MinimockSendMessageInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServerRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServerRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteChatMessagesDone() &&
		m.MinimockDeleteChatUsersDone() &&
		m.MinimockDeleteChatsUsersDone() &&
		m.MinimockSendMessageDone()
}
